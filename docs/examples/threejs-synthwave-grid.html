<!DOCTYPE html>
<!--
  EXAMPLE CODE: Three.js Synthwave Grid Animation

  Source: Created with Gemini, based on CodePen by pentagear
  CodePen: https://codepen.io/pentagear/pen/xxVbBZy

  Purpose: Reference implementation for 3D animated start screen
  See Beads ticket for integration plans.

  Features:
  - Infinite scrolling neon grid with terrain distortion
  - Procedural terrain using Simplex noise
  - Custom line shader with distance-based fade
  - Synthwave sun with gradient and scan lines
  - Post-processing bloom effects
  - Camera drift animation
  - Chunk-based recycling for infinite scrolling
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Drive - Drift Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 5px;
            pointer-events: none;
            text-shadow: 0 0 10px #0ff;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="loading">Systems Online</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            gridColor: new THREE.Color(0xff00ff),
            mountainColor: new THREE.Color(0x00ffff),
            skyColor: new THREE.Color(0x020008),
            sunColorTop: new THREE.Color(0xffaa00),
            sunColorBottom: new THREE.Color(0xff0066),

            speed: 40.0,
            distortionStrength: 55.0,

            // Chunk Settings
            chunkSize: 60,
            chunkCount: 18,

            // Resolution
            resX: 50,
            resZ: 4,

            gridWidth: 350,
            roadWidth: 12.0,

            // Visual Fade Settings
            fogDistance: 500,
            lineFadeStart: 100,
            lineFadeEnd: 350
        };

        // --- NOISE ---
        class SimplexNoise {
            constructor() {
                this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                this.p = [];
                for (let i=0; i<256; i++) this.p[i] = Math.floor(Math.random()*256);
                this.perm = [];
                for(let i=0; i<512; i++) this.perm[i]=this.p[i & 255];
            }
            dot(g, x, y) { return g[0]*x + g[1]*y; }
            noise(xin, yin) {
                let n0, n1, n2;
                const F2 = 0.5*(Math.sqrt(3.0)-1.0);
                const s = (xin+yin)*F2;
                const i = Math.floor(xin+s);
                const j = Math.floor(yin+s);
                const G2 = (3.0-Math.sqrt(3.0))/6.0;
                const t = (i+j)*G2;
                const X0 = i-t;
                const Y0 = j-t;
                const x0 = xin-X0;
                const y0 = yin-Y0;
                let i1, j1;
                if(x0>y0) {i1=1; j1=0;} else {i1=0; j1=1;}
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = this.perm[ii+this.perm[jj]] % 12;
                const gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
                const gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
                let t0 = 0.5 - x0*x0 - y0*y0;
                if(t0<0) n0 = 0.0; else {t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);}
                let t1 = 0.5 - x1*x1 - y1*y1;
                if(t1<0) n1 = 0.0; else {t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);}
                let t2 = 0.5 - x2*x2 - y2*y2;
                if(t2<0) n2 = 0.0; else {t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);}
                return 70.0 * (n0 + n1 + n2);
            }
        }
        const noise = new SimplexNoise();

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(CONFIG.skyColor, 100, CONFIG.fogDistance);
        scene.background = CONFIG.skyColor;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 20);
        camera.lookAt(0, 3, -50);

        // Anti-aliasing enabled to reduce strobing on distant lines
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.threshold = 0.0;
        bloom.strength = 1.3;
        bloom.radius = 0.4;
        composer.addPass(bloom);

        // --- CUSTOM LINE SHADER ---
        const fadeLineMaterial = new THREE.ShaderMaterial({
            uniforms: {
                fadeStart: { value: CONFIG.lineFadeStart },
                fadeEnd: { value: CONFIG.lineFadeEnd }
            },
            vertexShader: `
                attribute vec3 color;
                varying vec3 vColor;
                varying float vDist;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vDist = -mvPosition.z;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vDist;
                uniform float fadeStart;
                uniform float fadeEnd;

                void main() {
                    float alpha = 1.0 - smoothstep(fadeStart, fadeEnd, vDist);
                    if (alpha <= 0.01) discard;
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: true,
            depthWrite: false
        });

        // --- CHUNK CLASS ---
        class GridChunk {
            constructor(startZ) {
                this.group = new THREE.Group();
                this.startZ = startZ;

                this.createGeometry(startZ);
                this.group.position.z = 0;
                scene.add(this.group);
            }

            createGeometry(zOffset) {
                const width = CONFIG.gridWidth;
                const length = CONFIG.chunkSize;
                const resX = CONFIG.resX;
                const resZ = CONFIG.resZ;

                const vertices = [];
                const colors = [];
                const indices = [];
                const triIndices = [];

                const cRoad = CONFIG.gridColor;
                const cMtn = CONFIG.mountainColor;

                for (let z = 0; z <= resZ; z++) {
                    for (let x = 0; x <= resX; x++) {
                        const u = x / resX;
                        const v = z / resZ;

                        const px = (u - 0.5) * width;

                        // Local Z goes from 0 to -length
                        const localZ = -v * length;
                        const worldZ = zOffset + localZ;

                        // --- TERRAIN GENERATION V2 ---
                        let n = noise.noise(px * 0.02, worldZ * 0.02);
                        n = Math.max(0, n);
                        if (n > 0.6) {
                            n = 0.6 + (n - 0.6) * 0.2;
                        }

                        const distFromCenter = Math.abs(px);
                        let ramp = 0;
                        if (distFromCenter > CONFIG.roadWidth) {
                            const normDist = (distFromCenter - CONFIG.roadWidth) / 60.0;
                            ramp = Math.min(1.0, normDist);
                            ramp = Math.pow(ramp, 2.0);
                        }

                        const py = Math.max(0, n * CONFIG.distortionStrength * ramp);

                        vertices.push(px, py, worldZ);

                        // Color logic
                        if (distFromCenter <= CONFIG.roadWidth + 1.0) {
                            colors.push(cRoad.r, cRoad.g, cRoad.b);
                        } else {
                            colors.push(cMtn.r, cMtn.g, cMtn.b);
                        }
                    }
                }

                const cols = resX + 1;

                for (let z = 0; z < resZ; z++) {
                    for (let x = 0; x < resX; x++) {
                        const i = z * cols + x;

                        indices.push(i, i + 1);
                        indices.push(i, i + cols);

                        if (x === resX - 1) indices.push(i + 1, i + 1 + cols);

                        triIndices.push(i, i+1, i+cols);
                        triIndices.push(i+1, i+cols+1, i+cols);
                    }
                    if (z === resZ - 1) {
                        for (let x = 0; x < resX; x++) {
                             const i = (z + 1) * cols + x;
                             indices.push(i, i + 1);
                        }
                    }
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);

                const mesh = new THREE.LineSegments(geometry, fadeLineMaterial);

                const occGeo = new THREE.BufferGeometry();
                occGeo.setAttribute('position', geometry.getAttribute('position'));
                occGeo.setIndex(triIndices);
                const occMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.DoubleSide,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });
                const occMesh = new THREE.Mesh(occGeo, occMat);

                this.group.add(mesh);
                this.group.add(occMesh);
            }

            dispose() {
                scene.remove(this.group);
                this.group.children.forEach(c => {
                    if(c.geometry) c.geometry.dispose();
                    if(c.material) c.material.dispose();
                });
            }
        }

        // --- CHUNK MANAGER ---
        const chunks = [];

        for(let i = -1; i < CONFIG.chunkCount; i++) {
            chunks.push(new GridChunk(-i * CONFIG.chunkSize));
        }

        // --- SUN ---
        const sunGeo = new THREE.PlaneGeometry(100, 100);
        const sunMat = new THREE.ShaderMaterial({
            uniforms: {
                colorTop: { value: CONFIG.sunColorTop },
                colorBottom: { value: CONFIG.sunColorBottom }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform vec3 colorTop;
                uniform vec3 colorBottom;
                varying vec2 vUv;
                void main() {
                    vec3 color = mix(colorBottom, colorTop, vUv.y);
                    float stripe = sin(vUv.y * 60.0);
                    float gap = step(-0.6 + (vUv.y * 0.8), stripe);
                    float dist = distance(vUv, vec2(0.5));
                    float alpha = 1.0 - step(0.5, dist);
                    if(alpha < 0.1) discard;
                    gl_FragColor = vec4(color, alpha * gap);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        sun.position.set(0, 25, -300);
        scene.add(sun);

        // Infinite floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshBasicMaterial({color: 0x000000}));
        floor.rotation.x = -Math.PI/2;
        floor.position.y = -2;
        scene.add(floor);

        // --- ANIMATION ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime(); // We need time for the drift
            const moveDist = CONFIG.speed * delta;

            chunks.forEach(chunk => {
                chunk.group.position.z += moveDist;
            });

            // CAMERA DRIFT LOGIC
            // Slow sine wave for side-to-side drift
            const driftRange = 0.8; // How far to drift left/right
            const driftSpeed = 0.2; // How fast to drift

            camera.position.x = Math.sin(time * driftSpeed) * driftRange;
            // Add subtle bank/roll into the turn
            camera.rotation.z = Math.sin(time * driftSpeed) * -0.01;

            // Recycle Logic
            const firstChunk = chunks[0];
            const trailingEdgeZ = firstChunk.group.position.z + firstChunk.startZ - CONFIG.chunkSize;

            if (trailingEdgeZ > camera.position.z + 20) {
                const oldChunk = chunks.shift();
                oldChunk.dispose();

                const lastChunk = chunks[chunks.length - 1];
                const lastGeomZ = lastChunk.startZ;
                const newGeomZ = lastGeomZ - CONFIG.chunkSize;

                const newChunk = new GridChunk(newGeomZ);
                newChunk.group.position.z = lastChunk.group.position.z;

                chunks.push(newChunk);
            }

            sunMat.uniforms.colorTop.value = CONFIG.sunColorTop;
            composer.render();
        }

        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            composer.setSize(w, h);
        });

        document.getElementById('loading').style.opacity = 0;
        animate();

    </script>
</body>
</html>
