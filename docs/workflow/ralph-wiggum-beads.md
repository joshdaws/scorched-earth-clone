# Building a Game with Ralph Wiggum + Beads

This document explains how this repo was built using a "Ralph Wiggum" style autonomous agent loop combined with **Beads** for issue tracking.

**TL;DR:** Claude Code runs one issue at a time in a loop. When an issue is done, the loop restarts Claude fresh, grabs the next ready issue from Beads, and keeps going—until all work is complete.

---

## What is "Ralph Wiggum"?

"Ralph Wiggum" is a technique (not a product) for running AI coding agents autonomously. Instead of one long agent session that accumulates context and drifts over time, you:

> Do one thing → close it out → reboot → do the next thing

This keeps each run focused and avoids long-context degradation.

**Key insight:** Restarting the agent isn't a limitation—it's a feature. Each fresh session has full attention on a single, well-defined task.

**Resources:**
- [ghuntley.com/ralph](https://ghuntley.com/ralph/) — Original concept
- [YouTube walkthrough](https://www.youtube.com/watch?v=_IK18goX4X8)

---

## What is Beads?

[Beads](https://github.com/beads-ai/beads) is a CLI issue tracker with first-class dependency support. It acts as the work queue for the loop:

- Tracks what needs to be done
- Knows what's blocked vs. ready
- Stores acceptance criteria for each task
- Lives in the repo (`.beads/` directory)

The agent doesn't need to remember context across sessions—Beads holds the state. Each new Claude session asks "what's next?" and gets a focused task.

```bash
bd ready              # What can I work on?
bd show <issue-id>    # Full details + acceptance criteria
bd update <id> --status in_progress   # Claim it
bd close <id>         # Done
bd create --title "..." --type bug    # Found a problem
```

---

## The Process: From Zero to Playable Game

### Phase 1: Seed the Backlog

Before running the loop, I created **four seed issues** to bootstrap the project:

| Seed Issue | Purpose |
|------------|---------|
| **Research** | Study the original 1991 Scorched Earth—mechanics, weapons, gameplay feel. Document findings. |
| **Spec** | Convert research into a detailed specification for the synthwave reimagining. |
| **Tech Stack** | Decide on technologies (Canvas vs WebGL, build tools, etc.) and create setup tasks. |
| **Issue Breakdown** | Decompose the spec into small, implementable issues organized into epics. |

These planning issues generated the full backlog. After the breakdown issue completed, Beads contained **10 epics with 60+ child issues**—all the work needed to build the game.

### Phase 2: Run the Loop

The `ralph.sh` script runs the autonomous loop:

```bash
./ralph.sh --all              # Work on all open issues
./ralph.sh --epic <epic-id>   # Focus on one epic
./ralph.sh --type bug         # Just bugs
./ralph.sh --max 50           # Limit iterations
```

Each iteration:
1. Asks Beads for the next ready issue
2. Starts a **fresh** Claude Code session
3. Claude reads the issue, implements it, validates in browser
4. Claude closes the issue and commits
5. Loop restarts

### Phase 3: Results

| Metric | Value |
|--------|-------|
| Total issues created | 114 |
| Issues auto-generated by Claude | ~90 (from spec breakdown) |
| First run | 50 iterations, ~5.5 hours |
| Second run | Remaining ~40 issues overnight |
| Final state | Fully playable game |

The project went from empty repo to working game without manual coding.

---

## How the Loop Actually Works

### File Structure

```
.ralph/
  PROMPT.md       # Template prompt (with {{placeholders}})
  AGENT.md        # Project-specific instructions (patterns, file structure, etc.)
  progress.txt    # Log of completed work
  ralph.log       # Timestamped loop execution log
ralph.sh          # The loop runner script
```

### The Prompt Template

`.ralph/PROMPT.md` is a template that gets filled in each iteration. Key sections:

1. **Scope** — What subset of issues to work on
2. **Step-by-step instructions** — Claim issue → implement → validate → close
3. **Validation requirements** — Must test in browser before closing
4. **Issue creation rules** — How to file new bugs/tasks discovered during work

The template enforces discipline:
- **One issue per iteration** (prevents scope creep)
- **Acceptance criteria must be checked off** (prevents incomplete work)
- **Browser validation required** (catches runtime bugs)

### Self-Feeding Behavior

The most powerful aspect: **Claude can create new issues**.

When implementing a feature, Claude might discover:
- A bug in existing code → creates a bug issue
- A missing prerequisite → creates a task issue
- Edge cases not covered in spec → creates enhancement issues

These get added to Beads automatically. The loop will eventually pick them up. Nothing falls through the cracks.

---

## Project Memory Without Context Windows

Traditional approach: Keep everything in one long conversation, hope the agent remembers.

Ralph approach: **The repo is the memory.**

| What | Where |
|------|-------|
| What to build | `docs/specs/game-spec.md` |
| Technical decisions | `docs/architecture/tech-stack.md` |
| How to work in this codebase | `.ralph/AGENT.md` |
| What's done, what's next | Beads (`.beads/`) |
| Implementation details | The code itself + git history |

Each fresh Claude session reads what it needs. No context window bloat.

---

## Validation: The Backpressure That Makes It Work

The loop includes **mandatory browser testing** using Claude's browser automation:

```
1. Start local server
2. Navigate to http://localhost:8000
3. Take screenshot
4. Check console for errors
5. Test the specific feature
6. Only close issue if it actually works
```

This creates backpressure. Claude can't just write code and claim it's done—it has to prove the code works. Bad implementations get caught immediately rather than accumulating.

---

## Running It Yourself

### Prerequisites

- [Claude Code](https://claude.ai/code) installed and authenticated
- [Beads](https://github.com/beads-ai/beads) installed
- A repo with `.ralph/PROMPT.md` and `.ralph/AGENT.md`

### Typical Workflow

```bash
# 1. Create seed issues
bd create --title "Research: understand the problem domain"
bd create --title "Spec: define what we're building"
bd create --title "Breakdown: create implementation issues"

# 2. Run the loop
./ralph.sh --all --max 20

# 3. Monitor progress
bd status                    # Overall stats
cat .ralph/progress.txt      # What's been done
tail -f .ralph/ralph.log     # Live loop status
```

### Scoping Tips

- Start with a single epic: `./ralph.sh --epic <id>`
- Work on bugs separately: `./ralph.sh --type bug`
- Set conservative limits until you trust it: `--max 10`

---

## When This Approach Works Best

**Good fit:**
- Greenfield projects with clear specs
- Well-defined, decomposable work
- Projects where you can validate automatically (tests, browser, etc.)

**Higher risk:**
- Large existing codebases (blast radius concerns)
- Ambiguous requirements (agent may make wrong assumptions)
- Work requiring human judgment/creativity at each step

---

## Key Lessons

1. **Small issues > big issues.** The loop works best with focused, single-purpose tasks.

2. **Specs are leverage.** Time spent on research/spec pays off 10x in implementation.

3. **Backpressure matters.** Validation requirements (tests, browser checks) prevent drift.

4. **Let the agent create issues.** Self-feeding behavior catches gaps automatically.

5. **Fresh context is a feature.** Restarting prevents accumulation of confusion.

---

## FAQ

**Is this "vibe coding"?**

Sort of—but with guardrails. The loop is hands-off, but work is constrained to discrete issues and validated by automated checks.

**Is the code quality acceptable?**

In this project, yes. The output was surprisingly clean because:
- Small issues = focused implementations
- Validation requirements = working code
- Existing patterns in AGENT.md = consistency

**What if the agent gets stuck?**

It files an issue describing the blocker and moves on. The loop continues with other work. You can intervene manually on blocked issues later.

**Can I use this on my existing project?**

Maybe, with caution. Start with a small, isolated scope (one epic, one feature area). The technique is strongest when the blast radius of mistakes is small.
